buildscript{
  ext{
    springBootVersion = '1.5.2.RELEASE'
  }
  repositories {
    mavenLocal()
    mavenCentral()
    maven { url "http://repo.spring.io/release" }
    maven { url "http://repo.spring.io/milestone" }
    maven { url "http://repo.spring.io/snapshot" }
    maven { url "https://plugins.gradle.org/m2/" }
    jcenter()
  }
  dependencies{
    classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
    classpath 'com.bmuschko:gradle-docker-plugin:3.0.6'
    classpath "gradle.plugin.com.chrisgahlert:gradle-dcompose-plugin:0.9.0"
  }
}

apply plugin: 'groovy'
apply plugin: 'org.springframework.boot'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'com.bmuschko.docker-remote-api'

sourceCompatibility = 1.8
targetCompatibility = 1.8

repositories {
  mavenCentral()
  maven { url "http://repo.spring.io/release" }
  maven { url 'https://repo.spring.io/milestone' }
  maven { url 'https://repo.spring.io/snapshot' }
}

dependencies {
  compile 'org.codehaus.groovy:groovy-all:2.4.10'
  compile 'org.springframework.boot:spring-boot-starter-actuator'
  compile 'org.springframework.boot:spring-boot-starter-aop'
  compile 'org.springframework.boot:spring-boot-starter-data-cassandra'
  compile 'org.springframework.boot:spring-boot-starter-tomcat'
  compile 'org.springframework.boot:spring-boot-starter-web'
  compile 'org.springframework.retry:spring-retry'

  testCompile 'org.springframework.boot:spring-boot-starter-test'
  testCompile 'org.spockframework:spock-spring:1.1-groovy-2.4-rc-4'
  testCompile 'org.spockframework:spock-core:1.1-groovy-2.4-rc-4'
  testCompile 'io.rest-assured:rest-assured:3.0.2'
}

import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerPullImage
import com.bmuschko.gradle.docker.tasks.container.DockerCreateContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStartContainer
import com.bmuschko.gradle.docker.tasks.container.DockerWaitContainer
import com.bmuschko.gradle.docker.tasks.container.DockerCopyFileToContainer
import com.bmuschko.gradle.docker.tasks.container.DockerExecContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStopContainer
import com.bmuschko.gradle.docker.tasks.container.DockerRemoveContainer
import com.bmuschko.gradle.docker.tasks.image.Dockerfile

task createDockerfile(type: Dockerfile) {
  destFile = project.file('build/Dockerfile')
  from 'openjdk:8'
  workingDir '/usr/src/app'
  copyFile "libs/${project.name}-${project.version}.jar", '/usr/src/app'
  exposePort 8080
  defaultCommand "java", "-jar",  "/usr/src/app/${project.name}-${project.version}.jar"
}

task buildImage(type: DockerBuildImage) {
  dependsOn createDockerfile
  inputDir = createDockerfile.destFile.parentFile
  tag = "ncei/${rootProject.name}-${project.name}:${project.version}"
}

assemble.finalizedBy buildImage

apply plugin: "com.chrisgahlert.gradle-dcompose-plugin"

project.ext.set("composeNetworkName", "${project.name}_net")

dcompose {
  createComposeFile.useTags = true
  networks { "${project.ext.composeNetworkName}" }
  storage {
    image = "ncei/${rootProject.name}-${project.name}:${project.version}"
    networks = [network("${project.ext.composeNetworkName}")]
  }
  db {
    image = 'cassandra'
    networks = [network("${project.ext.composeNetworkName}")]
  }
}

assemble.finalizedBy createComposeFile

task pullCassandraImage(type: DockerPullImage) {
  repository = 'cassandra'
  tag = 'latest'
}

task createCassandraContainer(type: DockerCreateContainer) {
  dependsOn pullCassandraImage
  imageId = 'cassandra'
  containerName = 'storageCassandra'
  portBindings = ['9042:9042']
}

task startCassandraContainer(type: DockerStartContainer) {
  dependsOn createCassandraContainer
  targetContainerId { createCassandraContainer.getContainerId() }
}

task pullWaitImage(type: DockerPullImage) {
  repository = 'willwill/wait-for-it'
  tag = 'latest'
}

task createWaitContainer(type: DockerCreateContainer) {
  dependsOn pullWaitImage
  imageId = 'willwill/wait-for-it'
  cmd = ['-h', 'storageCassandra', '-p', '9042']
}

task startWaitContainer(type: DockerStartContainer) {
  dependsOn createWaitContainer
  targetContainerId { createWaitContainer.getContainerId() }
}

task waitForCassandra(type: DockerWaitContainer) {
  dependsOn startCassandraContainer, startWaitContainer
  targetContainerId { createWaitContainer.getContainerId() }
}

task copyCqlToCassandra(type: DockerCopyFileToContainer) {
  dependsOn startCassandraContainer
  targetContainerId { createCassandraContainer.getContainerId() }
  hostPath = './cql/createKeyspaceAndTables.cql'
  remotePath = '/tmp'
}

task bootstrapCassandra(type: DockerExecContainer) {
  dependsOn copyCqlToCassandra, waitForCassandra
  targetContainerId { createCassandraContainer.getContainerId() }
  cmd = ['cqlsh', '-f', '/tmp/createKeyspaceAndTables.cql']
}

task stopCassandraContainer(type: DockerStopContainer) {
  targetContainerId { createCassandraContainer.getContainerId() }
}

task removeCassandraContainer(type: DockerRemoveContainer) {
  mustRunAfter stopCassandraContainer
  targetContainerId { createCassandraContainer.getContainerId() }
  force = true
}

configurations.configure {
  integrationTestCompile.extendsFrom testCompile
  integrationTestRuntime.extendsFrom testRuntime
}

sourceSets {
  integrationTest {
    groovy.srcDir file('src/integrationTest/groovy')
    //resources.srcDir file('src/integrationTest/resources')
    compileClasspath += main.output + test.output + configurations.testRuntime
    runtimeClasspath += output + compileClasspath
  }
}

task integrationTest(type: Test, description: 'Runs the integration tests', group: 'verification') {
  mustRunAfter test
  dependsOn bootstrapCassandra
  finalizedBy removeCassandraContainer

  testClassesDir = sourceSets.integrationTest.output.classesDir
  classpath = sourceSets.integrationTest.runtimeClasspath
  reports.junitXml.destination = 'build/integration-test-results'
  reports.html.destination = 'build/reports/integrationTests'
}

check.dependsOn integrationTest
